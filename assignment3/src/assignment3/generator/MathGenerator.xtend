/*
 * generated by Xtext 2.25.0
 */
package assignment3.generator

import assignment3.math.Div
import assignment3.math.LetBinding
import assignment3.math.MathExp
import assignment3.math.MathNumber
import assignment3.math.Minus
import assignment3.math.Mult
import assignment3.math.Plus
import assignment3.math.VarBinding
import assignment3.math.VariableUse
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(MathExp))) {
			fsa.generateFile(("math_expression/") + e.name.toString() + ".java", e.compile)
		}

	}

	def compile(MathExp math) {
		val class_name = MathExp.name
		'''
		package math_expression;
		
		public class «class_name» {
			«FOR exp : math.variables» 
				public int «exp.name»;
			«ENDFOR»
			
			«IF math.externals.size > 0»
				private External external
			
				public «class_name»(External external) {
					this.external = external;
				}
			«ENDIF»		
			
		public void compute() {
			«FOR exp : math.variables» 
			«exp.name» = «exp.expression.computeExpressionString»;
			«ENDFOR»
		}
			
				«IF math.externals.size > 0»
					public interface External {
					}
				«ENDIF»
		
		}
		'''
	}
	
	def static dispatch String computeExpressionString(MathNumber exp) {
		exp.value.toString
	}

	def static dispatch String computeExpressionString(Plus exp) {
		exp.left.computeExpressionString +' + '+ exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Minus exp) {
		exp.left.computeExpressionString + ' - ' + exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Mult exp) {
		exp.left.computeExpressionString +' * '+ exp.right.computeExpressionString
	}
	
	def static dispatch String computeExpressionString(Div exp) {
		exp.left.computeExpressionString + ' / '+ exp.right.computeExpressionString
	}
	

	def static dispatch int computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}

	def static dispatch int computeExpression(MathNumber exp) {
		exp.value
	}

	def static dispatch int computeExpression(Plus exp) {
		exp.left.computeExpression + exp.right.computeExpression
	}

	def static dispatch int computeExpression(Minus exp) {
		exp.left.computeExpression - exp.right.computeExpression
	}

	def static dispatch int computeExpression(Mult exp) {
		exp.left.computeExpression * exp.right.computeExpression
	}

	def static dispatch int computeExpression(Div exp) {
		exp.left.computeExpression / exp.right.computeExpression
	}

	def static dispatch int computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}

	def static dispatch int computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}

	def static dispatch int computeBinding(VarBinding binding) {
		if (!variables.containsKey(binding.name))
			binding.computeExpression()
		variables.get(binding.name)
	}

	def static dispatch int computeBinding(LetBinding binding) {
		binding.binding.computeExpression
	}

}
